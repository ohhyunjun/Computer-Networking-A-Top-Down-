## 전체적인 계층의 범위와 역할
![Image](https://github.com/user-attachments/assets/5d51ff50-c339-4930-b21d-c3604f27b312)

## 1. 전송계층 서비스와 프로토콜
- 서로 다른 호스트 간의 프로세스 간에 논리적 통신을 한다.
  - **프로토콜**: 엔드 시스템에서 실행된다. (인터넷: TCP, UDP)
    - **TCP**: 신뢰성, 연결지향적, 혼잡제어, 흐름제어
    - **UDP**: 비신뢰성
    - **공통점**: 지연보장과 대역폭 보장 안 함.
  - **송신측**: 메시지(애플리케이션 계층)를 세그먼트로 나누고 네트워크 계층으로 보냄.
  - **수신측**: 세그먼트를 메시지로 재구성하고 애플리케이션 계층으로 보냄.
  - **전송 계층**: <우편함에서 해당 집 호수 사이>
  - **네트워크 계층**: <우편함과 우편함 사이>
    - **시나리오**:
      - 프로세스는 아이들
      - 애플리케이션 메시지는 편지
      - 호스트는 집
      - 전송계층은 안과 빌
      - 네트워크 계층은 우편 서비스

## 2. Multiplexing and Demultiplexing
- **멀티플렉싱**: 여러 데이터스트림(500명의 사람)을 하나의 통신 링크(길)를 통해 여러 방법(TDMA, FDMA)으로 전송할 수 있게 하는 '프로세스'.
- **디멀티플렉싱**: 수신받은 단일 데이터 스트림을 여러 데이터 스트림(500명의 사람)으로 분리하고 원래 대상 응용 프로그램(각각의 최종 호텔 방)으로 라우팅(호텔방을 배정)하는 과정
  - **작동 방식**:
    - 호스트는 송신측 IP와 수신측 IP 주소가 담긴 데이터그램을 받는다.
    - 데이터그램 속 1개의 세그먼트 헤더를 가지고 있으며, 그러한 세그먼트는 목적지 포트번호를 가지고 있다.
    - 호스트는 IP 주소와 포트번호를 통해 세그먼트를 적절한 소켓으로 보낸다.
- **UDP 소켓**: 비연결성 디멀티플렉싱으로 IP와 포트넘버를 합친 소켓이다.
  - **two-tuple**: 목적지 IP 주소, 목적지 포트 번호 = 해당 two-tuple로 UDP 소켓을 식별한다.
  - 호스트가 UDP 세그먼트를 수신하면 목적지 포트를 확인하고 해당 포트로 세그먼트를 소켓으로 전송한다.
- **TCP 소켓**: 연결지향 디멀티플렉싱으로 IP와 포트넘버를 합친 소켓이다.
  - **4-tuple**: 송신측 IP 주소와 포트 번호, 수신측 IP 주소와 포트번호 = 해당 4-tuple로 TCP 소켓을 식별한다.
  - 수신측 호스트는 소켓의 수신측 정보를 통해 적절히 해당 포트로 보내며, 송신측 정보를 통해 송신측에 잘 도착했음을 다시 보낸다.
  - TCP는 만약 n개의 정보가 들어오면 총 n+1(웰컴소켓)개의 소켓이 필요하다.

## 3. Connectionless Transport: UDP
- **UDP**:
  - 송신과 수신측 사이에 핸드쉐이킹이 없음(연결 설정이 없기에 지연을 줄일 수 있음).
  - 간단함(단순함).
  - 작은 세그먼트 헤더를 가짐.
  - 혼잡제어가 없음.
- **사용 예**:
  - 스트리밍 서비스, DNS, SNMP에 쓰임.
- **체크섬**: 세그먼트에서 에러 '감지'를 목표.
 ![Image](https://github.com/user-attachments/assets/da30c4f6-b229-42f4-89b4-57cf668893b2)


## 4. Principles of Reliable Data Transfer
- **방식**:
  - Stop and Wait
  - Sliding Window (Pipeline, Go Back N, Selective Repeat)
- **rdt3.0**: Stop and Wait 방식으로 보내고 ACK가 일정 시간 동안 오지 않으면 다시 보낸다.
  ![Image](https://github.com/user-attachments/assets/9b2286f8-b8fa-4a13-878b-b908450421e7)
  ![Image](https://github.com/user-attachments/assets/e0857ccc-b32e-41ef-9497-f8e1bec641c0)
  
  ### 네트워크 성능 계산

    #### 기본 조건

    - **링크 용량**: `1Gbps` (1,000,000,000 bits per second)
    - **패킷 크기**: `1KB` (1 kilobyte = 8000 bits)
    - **전파 지연 (End-to-End Propagation Delay)**: `15ms` (15 milliseconds)
    - **패킷 전송 시간 (Transmission Time)**: 패킷 길이를 링크 용량으로 나눈 값 = 패킷 전송시간 = L/R
      - 계산: `8000 bits / 10^9 bits/sec = 8 microseconds`

    #### 활용도 계산 공식

    ```plaintext
    U_sender(송신자가 데이터를 전송하는데 사용하는 시간의 비율) = (L / R) / (RTT + (L / R))
                                                              = 0.008/(15ms*2+0.008) = 0.00027
    ```
  - **결론**:  
      이론적 최대 대역폭은 1Gbps에 달하지만, 주어진 네트워크 조건(전파 지연 및 패킷 크기 등)에서는 실제로 초당 약 33KB의 데이터만을 전송할 수 있습니다.
      1초는 1000ms이므로, 1초 동안 전송할 수 있는 패킷의 수를 계산하면 1초/30ms = 33 즉 33KB임
    ![Image](https://github.com/user-attachments/assets/1e519609-449f-406e-a877-ead6a1ba371a)
    
- **GBN**: 패킷에 오류 또는 손실이 발생 시 해당 패킷부터 모든 패킷을 재전송하는 방식 (ARQ: 자동 반복 요청, 오류를 감지하고 신뢰성을 제공하기 위한 기술)
  - **Window Size**: Sender가 ACK 받기 전 최대로 보낼 수 있는 패킷의 수
  - **Send_base**: 송신자가 이미 보냈지만 아직 ACK 받지 못한 가장 첫 번째 시퀀스 번호
  - **Nextseqnum**: 송신자가 현재 전송할 수 있는 다음 패킷 시퀀스 번호
  - **수신자 동작**:
     - 패킷들을 연속해서 받고 각 패킷을 받을 때 넘버를 확인하고 ACK 전송 (정상적으로 받은 가장 마지막 패킷 번호를 ACK에 담아 보냄).
  - **장점**:
     - 손실된 데이터부터는 모두 송신측으로부터 재전송되므로 수신측은 해당 데이터들을 버퍼링할 필요 없다.
  ![Image](https://github.com/user-attachments/assets/707d28c1-7b4e-48fd-b43d-30da6d5fa366)
- **Selective Repeat**: 모두 재전송하는 GBN을 개선한 방식으로 수신자가 수신한 각각의 패킷에 대해 개별적인 확인 응답을 보내는 방식.
  - 각각의 패킷에 대해 타이머를 가지고 있어 time-out을 활용해 재전송한다.
  - 수신자가 버퍼를 가지고 있어 중간에 받지 못한 시퀀스 넘버 뒤의 패킷을 버리지 않고 버퍼에 저장하였다가 해당 시퀀스 넘버의 패킷을 받으면 버퍼의 패킷들과 합쳐서 상위 계층으로 보낸다.
  ![Image](https://github.com/user-attachments/assets/4a327176-743c-4cb7-840f-4f5c1b57d310)

## 5. Connection-Oriented Transport: TCP

### ACK의 의미  
- 수신 측은 **다음으로 기대하는 바이트의 시퀀스 번호**를 ACK 번호에 담아 송신 측에 전달합니다.

### Three-Way Handshake (연결 설정 과정)
TCP 연결을 맺기 위해 세 단계의 핸드셰이크 과정을 거칩니다:

1. **클라이언트 → 서버**  
   `SYN` 세그먼트를 보냄 (초기 시퀀스 번호 포함, 데이터 없음)

2. **서버 → 클라이언트**  
   `SYN-ACK` 세그먼트로 응답 (서버의 초기 시퀀스 설정, 버퍼 할당)

3. **클라이언트 → 서버**  
   `ACK` 세그먼트로 응답 (필요 시 데이터 포함)

## 6. Principles of Congestion Control

### Congestion (혼잡)의 개념
- 네트워크에서 **과도한 트래픽**으로 인해 라우터나 링크가 패킷을 처리하지 못하는 현상
- 결과: **패킷 손실**, **지연 증가**

### 흐름 제어 vs 혼잡 제어
| 항목 | 흐름 제어 (Flow Control) | 혼잡 제어 (Congestion Control) |
|------|---------------------------|----------------------------------|
| 목적 | 수신측 처리 속도 보장 | 네트워크 전체의 혼잡 완화 |
| 기준 | 수신측 상태 | 네트워크 상태 추정 (End-to-End) |

### 해결 방법
- TCP는 수신자의 **ACK 응답 유무**를 기반으로 혼잡을 판단  
- 이를 통해 송신 측이 전송 속도를 조절

## 7. TCP Congestion Control

### cwnd (Congestion Window)
- 송신 측이 혼잡도를 고려하여 **한 번에 전송할 수 있는 데이터 양(MSS 단위)**을 제한하는 변수

### 혼잡 제어 방식 요약

| 단계 | 설명 |
|------|------|
| **Slow Start** | - 시작: `cwnd = 1 MSS`<br>- ACK 수신 시마다 `cwnd` **2배로 증가**<br>- 손실 발생 시 종료 |
| **Congestion Avoidance** | - `cwnd`를 **1 MSS씩 선형 증가**<br>- 손실 발생 시 감소 |
| **Fast Recovery** | - **3 중복 ACK** 수신 시 혼잡으로 판단<br>- `ssthresh = cwnd / 2`, `cwnd = cwnd / 2` 설정<br>- 이후 선형 증가 |

### TCP 버전별 동작 차이

| 버전 | 동작 방식 |
|------|-----------|
| **TCP Reno** | - `cwnd / 2`로 줄이고 **선형 증가** |
| **TCP Tahoe** | - `cwnd = 1 MSS`로 설정 후 **Slow Start 재시작** |

---

> 참고: TCP 혼잡 제어는 네트워크의 효율성과 안정성을 보장하기 위한 핵심 메커니즘입니다. 연결지향적 특성을 기반으로 하여 신뢰성과 혼잡 회피를 동시에 달성합니다.
